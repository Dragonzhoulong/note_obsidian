具体来说, B 阶段的任务又可以分成如下部分:

```

1. 搭建基础设施. 基础设施是指提升调试效率的工具和方法. 如果你已经听说过第三期"一生一芯"的DiffTest(差分测试)机制, 相信你也大概能够明白基础设施对于一个有一定规模的项目来说多么的重要了.除了DiffTest之外, 你还会实现简易调试器和各种trace(踪迹)工具, 这些基础设施将会伴随你整个"一生一芯"的学习: 即使到了A阶段和S阶段, 你会发现它们仍然可以大幅提升调试的效率; 甚至可以说, 如果没有这些基础设施, 你想要在S阶段中存活下来, 将要付出巨大的代价.
2. 设计一个支持RV32E的单周期处理器. 不过你会首先实现一个RV32IM(对, 是RV32IM)的模拟器, 在不接触RTL实现细节的情况下理解RISC-V指令和程序的行为, 然后再把这些理解迁移到RTL实现的真实处理器中.
3. 为单周期处理器添加输入输出功能. 这样以后, 你就可以在自己设计的处理器上运行超级玛丽了.
4. 实现简单的异常处理机制, 运行RT-Thread操作系统
5. 实现总线, 接入SoC
6. 将处理器改成流水线结构
```
Understanding Integer Overflow in C/C++

我们在 PA1 中提到:

> 我们可以看到 `cpu_exec()` 模拟了 CPU 的工作方式: 不断执行指令. `fetch_decode_exec_updatepc()` 函数 (在 `nemu/src/cpu/cpu-exec.c` 中定义) 让 CPU 执行当前 PC 指向的一条指令, 然后更新 PC.

`Decode` 类型的结构体指针是 `s` , 这个结构体用于存放在执行一条指令过程中的译码和执行信息

byd 真得开始看一生一芯了 

## [xv6](../xv6.md) 
>qemu-system-riscv64 -machine virt -bios none -kernel kernel/kernel -m 128M -sm

启动了一个 riscv64 的虚拟机, 在虚拟机里可以体验一个真正的 unix shell 

程序的执行 (状态序列变化) 有时候比代码 (状态机) 更容易理解

## vim 技巧
### 匹配替换空格
这个 Vim 命令 `:%s/ /\r /g` 的目的是在每个空格后插入一个回车符（换行符）。这里的 `\r` 表示回车符，空格前面的空格是你要查找的模式。

这个命令的详细解释如下：

- `:%s/ /` : `%` 表示在整个文档中查找，`s/ /` 表示查找空格。
- `\r /` : `\r` 表示回车符，紧跟着一个空格，表示在每个空格后插入回车符。
- `g` : 表示全局替换，即一行中的所有匹配项都会被替换。

因此，这个命令会将文档中每个空格后都插入一个回车符。

注意：这可能会导致文本内容的布局变得混乱，因为它会在每个空格后插入新的行。确保了解这个操作的影响，以免不必要的格式混乱。

在 Vim 中，`:set nowrap` 是用来关闭文本自动换行的命令。如果你执行了这个命令，Vim 将不再自动将文本折行显示，而是让文本在水平方向上自由滚动。

这对于查看一些较长的行或者希望在编辑时水平滚动而不是自动换行的情况很有用。

如果你想重新启用文本自动换行，可以执行 `:set wrap`。这将恢复 Vim 的默认设置，自动将文本折行显示。
### 关闭自动换行

总之，`:set nowrap` 用于关闭自动换行，而 `:set wrap` 用于重新启用自动换行。

## 关于 mkfs
在 Makefile 中的 `mkfs` 通常是一个用于创建文件系统的命令或目标。这个命令通常用于生成一个文件系统镜像，该镜像可以被用于嵌入式系统、虚拟机、或其他系统开发和测试的环境中。

`mkfs` 命令通常被用于以下目的：

1. **文件系统创建：** 创建一个文件系统，将文件、目录和文件系统的元数据组织到磁盘或内存块设备上。

2. **格式化磁盘：** 在硬盘或其他存储设备上创建一个文件系统，使其可以被操作系统识别和使用。

3. **制作文件系统镜像：** 将创建的文件系统打包成一个镜像文件，该文件可以在不同的环境中使用。

在一个典型的 Makefile 中，你可能会看到类似以下的规则：

```make
fs.img: mkfs
    ./mkfs fs.img
```

这表示 `fs.img` 是由 `mkfs` 目标生成的。在执行 `make fs.img` 时，Makefile 会检查 `mkfs` 是否需要更新，如果需要，它将先执行 `mkfs` 目标，然后再执行 `./mkfs fs.img` 命令来生成 `fs.img` 文件。

注意：实际的 `mkfs` 命令和参数可能因项目而异，具体取决于你的项目和所用的工具链。如果你能提供更多的上下文或 Makefile 片段，我可以提供更详细的帮助。

```makefile


```

如何生成 `compile_command.json`
## 关于 bear

`bear` 是一个用于生成编译数据库（Compilation Database）的命令行工具。编译数据库是一种记录源代码文件和它们之间的编译命令关系的格式，通常用于与构建系统集成、代码分析工具或 IDE（集成开发环境）的代码导航等。

`bear` 的主要作用是在构建项目时截获编译命令，并将其保存到 `compile_commands.json` 文件中，该文件是标准的编译数据库格式。

以下是一些常见的用途和特点：

1. **与构建系统集成：** `bear` 可以与常见的构建系统（如 Make、CMake 等）一起使用，以自动捕获编译命令。

2. **与代码编辑器和 IDE 集成：** 通过生成编译数据库，`bear` 允许代码编辑器和 IDE 在源代码中提供更强大的代码导航、补全和静态分析等功能。

3. **跨平台：** `bear` 在不同的操作系统上都可以使用，因为它并不依赖于特定的编译器或构建系统。

4. **使用示例：** 在项目的源代码目录中，你可以运行 `bear make` 或 `bear cmake`，`bear` 将记录构建期间的编译命令并生成 `compile_commands.json` 文件。

请注意，`bear` 通常需要安装在系统中，你可以使用系统的包管理器（如 `apt`、`yum`、`brew` 等）来安装它。例如，在 Ubuntu 系统上，你可以运行：

```bash
sudo apt-get install bear
```

希望这些信息能帮助你了解 `bear` 命令行工具。如果有更具体的问题或需求，欢迎提出。

## vscode 和 vim 的杂交
一股势力告诉你, 要坚持看下去, 一股势力告诉你好麻烦不想看下去, 工具的意义让你更容易的往好的方向去做

## 为什么要学操作系统?
------
为什么要学操作系统呢?
+ 为什么要学习微积分/离散数学/xxx?
+ 老东西: ~~擦干泪不要问为什么~~
微积分"被混起来的"几件事情
+ Newton 时代的微积分
+ 现代方法: sympy, sage
	+ 所以第一门语言应该学 python
+ cauchy 时代的微积分 (严格化和公理化)
+ 微积分的现代应用
	+ 优化, 有限元, PID
### 学习操作系统的目的
------
你体内的"编程力量"尚未觉醒
+ 每天都在用的东西, 你还没有搞明白
	+ 窗口是怎么创建的? 为什么 `ctrl+c` 可以退出程序, 为什么又是不可以
	+  组里的服务器有 128 个处理器, 但是你的程序却只能用一个
	+ 你每天都在用的东西, 但是你却实现不出来
		+ 浏览器, 编译器, IDE, 游戏外挂, 任务管理器, 杀毒软件
`操作系统给你有关编程的全部`
+ 悟性好: 学完课程就在系统方向"毕业"
	+ 具有编写出来一切可以写出来的程序的能力
+ 悟性差: 内力大增
	+ 可能工作中的某一天想起来课程的内容

不能失去 integrity
### 操作系统是干甚的
管理软硬件资源
  

## 状态机
数字逻辑电路
+ 状态 = 寄存器
+ 初始状态 = reset
+ 迁移 = 组合逻辑电路计算寄存器下一周期的值

如何支持富文件? (不光分享页面还要分享各种文件的个人网站)

  舒服了两天打完胶速速干 PA
  
-------
## 数字电路的查找表 (Lookup Table)
在实际的电路设计中, 查找表可以通过存储器元件实现

### yemu
```c
#define DECODE_R(inst) uint8_t rt = (inst).rtype.rt, rs = (inst).rtype.rs

#define DECODE_M(inst) uint8_t addr = (inst).mtype.addr
```
这两行代码定义了两个宏，`DECODE_R` 和 `DECODE_M`。在 C 语言中，宏是一种预处理器指令，它们在编译时会被宏定义的内容所替换。

这里的宏定义使用了 `#define` 指令，后面跟着宏的名称（例如 `DECODE_R` 或 `DECODE_M`）和宏的内容。在这个例子中，宏的内容是一些 C 语言的代码。

`DECODE_R(inst)` 宏的内容是 `uint8_t rt = (inst).rtype.rt, rs = (inst).rtype.rs`。这行代码定义了两个 `uint8_t` 类型的变量 `rt` 和 `rs`，并将它们初始化为 `inst` 的 `rtype` 字段的 `rt` 和 `rs` 成员。这里的 `inst` 是宏参数，它在宏被使用时会被实际的参数值所替换。

同样，`DECODE_M(inst)` 宏的内容是 `uint8_t addr = (inst).mtype.addr`。这行代码定义了一个 `uint8_t` 类型的变量 `addr`，并将其初始化为 `inst` 的 `mtype` 字段的 `addr` 成员。

这样的宏定义可以让我们在代码中方便地提取出 `inst` 的不同字段，而不需要每次都写出完整的提取代码。例如，我们可以写 `DECODE_R(myInst)` 来提取出 `myInst` 的 `rtype` 字段的 `rt` 和 `rs` 成员，并将它们赋值给新的变量 `rt` 和 `rs`。

### `gdb` 可以指定循环执行的次数么
是的，gdb 提供了一个命令 "ignore"，可以让你指定一个断点被忽略的次数。这意味着 gdb 将在这个断点被触发指定次数后才会暂停执行。以下是如何使用 "ignore" 命令：

首先，你需要设置一个断点。例如，如果你想在 `exec_once` 函数上设置一个断点，你可以使用以下的命令：

```bash
break exec_once
```

然后，你可以使用 "ignore" 命令来指定这个断点被忽略的次数。例如，如果你想让 gdb 在这个断点被触发 100 次后才暂停执行，你可以使用以下的命令：

```bash
ignore 1 100
```

在这个命令中，"1" 是断点的编号，"100" 是这个断点被忽略的次数。你需要将 "1" 替换为你的断点的实际编号。你可以使用 "info breakpoints" 命令来查看所有的断点和它们的编号。

## vscode 配置相关
